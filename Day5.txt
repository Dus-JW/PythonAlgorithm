1. 기초지식

integer overflow = 알고있음

(1 * 2 * 3 ~ * 49 * 50) % 61
== (1 % 61) * (2 % 61) * (3 % 61) * (4 % 61) ~

* 실수의 지식

float 는 4byte
double 은 8byte

float는 sign 1 bit , exponent 8 bit, fraction field 23bit
double은 sign 1 bit, exponent 11 bit, fraction field 52bit

기본적으로 알고리즘 문제를 풀 때 메모리 문제로 인해 double을 쓰면
안되는 이유를 찾지 못했다. 때문에, 실수 관련 문제는 double로 풀 것

double에 longlong 범위의 정수를 담으면 유효숫자 자릿수 15자리를 넘어가기
때문에 오차가 발생한다.

실수를 비교할 때는 등호를 사용하면 안된다.

* 전역변수와 지역변수

일반적인 개발에서는 전역변수의 사용을 자제하고 포인터 혹은 참조자를 이용해함수간 데이터를 넘겨준다.
하지만 코딩테스트에서는 빠르게 코딩하는 것이 관건이기에 전역변수를 마음껏 써서 함수 인자를 적는데 시간 낭비를 하지 않는다.

지역 변수는 0으로 초기화되지 않지만 전역변수는 0으로 초기화 된다.

* 코드 작성 요령

어느정도의 템플릿은 구현해놓는 것이 좋다.

ex) #include <bits/stdc++.h>

문제를 풀고난 뒤 다른 사람의 코드를 보고 어떻게 접근했는지 이해하는 것도 중요하다.

아직 이론을 많이 모르고 구현력을 늘리는 것이 시급한 초보한테는 너무 오랜 시간 고민하는 것 보다 30분 ~ 1시간 정도 고민한 후 빠르게 풀이를 참고하는 것이 좋다.

* STL과 함수인자

그냥 C언어에서는 스왑함수를 포인터로 인자를 받아 해결하는데, C++에서는 하나의 방법이 더있다. 바로 참조자.

참조자를 이용하여 함수 내의 코드에서는 그냥 int를 쓰듯 tmp에 a를 대입하고 a에 b를 대입하고 할 수 있는데, 다 원본 변수를 이용하는 것이다.

ex) void swap3(int &a, int &b)
{
	int	tmp = a;
	a = b;
	b = tmp;
}

STL == Standard Template Libarary

C++에는 다양한 알고리즘과 자료구조가 STL에 구현되어있다.

예를 들어, 원래는 C++에서 배열을 선언할 때 크기를 명시해야 하고 무조건 해당 크기 안에서만 사용을 해야한다.
그런데 vector는 일종의 가변 배열로 크기를 마음대로 늘렸다 줄였다 할 수 있다.

ex) vector<int> v(100);
v[20] = 10;
v[60] = -4;
가 가능하다.

또한 STL의 경우도 함수에서 인자로 받을 때, 복사본을 받기 때문에 참조자를 잘 이용하여 풀어야 할 것. 왜냐하면 참조자를 이용해야 시간 복잡도를 많이 잡을 수 있기 때문이다. (참조자를 사용하지 않을 경우 복사본을 가져오기 때문에 시간 복잡도가 O(N)이 될 수 있다.)

코딩테스트에서는 endl을 사용하면 안된다. (시간 복잡도를 잡아먹기 때문)

10 5
1 10 4 9 2 3 8 5 7 6

1 4 2 3

* 코드 작성 팁

1. 출력 맨 마지막 공백 혹은 줄바꿈이 추가로 있어도 상관 없다.
2. 디버거는 굳이 사용하지 않아도 된다.
